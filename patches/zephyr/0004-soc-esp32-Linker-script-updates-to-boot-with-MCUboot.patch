From 0ce87c382bd6bcd632eee9f07741e914c94c1d5d Mon Sep 17 00:00:00 2001
From: Shubham Kulkarni <shubham.kulkarni@espressif.com>
Date: Mon, 30 Aug 2021 17:20:55 +0530
Subject: [PATCH] soc: esp32: Linker script updates to boot with MCUboot

This change creates XiP image with proper LMA and VMA to boot with
MCUboot

Signed-off-by: Shubham Kulkarni <shubham.kulkarni@espressif.com>
---
 soc/xtensa/esp32/linker.ld | 499 +++++++++++++++++++------------------
 1 file changed, 258 insertions(+), 241 deletions(-)

diff --git a/soc/xtensa/esp32/linker.ld b/soc/xtensa/esp32/linker.ld
index a11ed041b9..9d1561776c 100644
--- a/soc/xtensa/esp32/linker.ld
+++ b/soc/xtensa/esp32/linker.ld
@@ -18,16 +18,37 @@
 #include <linker/linker-defs.h>
 #include <linker/linker-tool.h>
 
-#define RAMABLE_REGION dram0_0_seg :dram0_0_phdr
-#define RAMABLE_REGION_1 dram0_1_seg :dram0_1_phdr
-#define ROMABLE_REGION drom0_0_seg :drom0_0_phdr
-#define IRAM_REGION iram0_0_seg :iram0_0_phdr
-#define FLASH_CODE_REGION irom0_0_seg :irom0_0_phdr
+#define RAMABLE_REGION dram0_0_seg
+#define RAMABLE_REGION_1 dram0_1_seg
+#define RODATA_REGION drom0_0_seg
+#define IRAM_REGION iram0_0_seg
+#define FLASH_CODE_REGION irom0_0_seg
+
+#define ROMABLE_REGION ROM
+
+#ifdef CONFIG_FLASH_SIZE
+#define ROM_SIZE CONFIG_FLASH_SIZE
+#else
+#define ROM_SIZE 0x400000
+#endif
+
+#ifdef CONFIG_BOOTLOADER_ESP_IDF
+#define IROM_SEG_ORG 0x400D0020
+#define IROM_SEG_LEN 0x330000-0x20
+#define IROM_SEG_ALIGN 0x4
+#else
+#define IROM_SEG_ORG 0x400D0000
+#define IROM_SEG_LEN 0x330000
+#define IROM_SEG_ALIGN 0x10000
+#endif
 
 MEMORY
 {
+  mcuboot_hdr (RX): org = 0x0, len = 0x20
+  metadata (RX): org = 0x20, len = 0x20
+  ROM (RX): org = 0x40, len = ROM_SIZE - 0x40
   iram0_0_seg(RX): org = 0x40080000, len = 0x20000
-  irom0_0_seg(RX): org = 0x400D0020, len = 0x330000-0x20
+  irom0_0_seg(RX): org = IROM_SEG_ORG, len = IROM_SEG_LEN
   /*
    * Following is DRAM memory split with reserved address ranges in ESP32:
    *
@@ -42,7 +63,13 @@ MEMORY
    */
   dram0_0_seg(RW): org = 0x3FFB0000 + CONFIG_ESP32_BT_RESERVE_DRAM, len = 0x2c200 - CONFIG_ESP32_BT_RESERVE_DRAM
   dram0_1_seg(RW): org = 0x3FFE4350, len = 0x1BCB0
-  drom0_0_seg(R): org = 0x3F400020, len = 0x400000-0x20
+
+  /* DROM is the first segment placed in generated binary.
+   * MCUboot binary for ESP32 has image header of 0x20 bytes.
+   * Additional load header of 0x20 bytes are appended to the image.
+   * Hence, an offset of 0x40 is added to DROM segment origin.
+   */
+  drom0_0_seg(R): org = 0x3F400040, len = 0x400000 - 0x40
   rtc_iram_seg(RWX): org = 0x400C0000, len = 0x2000
   rtc_slow_seg(RW): org = 0x50000000, len = 0x1000
 #if defined(CONFIG_ESP_SPIRAM)
@@ -53,15 +80,6 @@ MEMORY
 #endif
 }
 
-PHDRS
-{
-  drom0_0_phdr PT_LOAD;
-  dram0_0_phdr PT_LOAD;
-  dram0_1_phdr PT_LOAD;
-  iram0_0_phdr PT_LOAD;
-  irom0_0_phdr PT_LOAD;
-}
-
 /*  Default entry point:  */
 PROVIDE ( _ResetVector = 0x40000400 );
 ENTRY(CONFIG_KERNEL_ENTRY)
@@ -73,193 +91,55 @@ PROVIDE(_memmap_reset_vector = 0x40000400);
 
 SECTIONS
 {
-
-#include <linker/rel-sections.ld>
-
-  /* RTC fast memory holds RTC wake stub code,
-     including from any source file named rtc_wake_stub*.c
-  */
-  .rtc.text :
-  {
-    . = ALIGN(4);
-    *(.rtc.literal .rtc.text)
-    *rtc_wake_stub*.o(.literal .text .literal.* .text.*)
-  } >rtc_iram_seg
-
-  /* RTC slow memory holds RTC wake stub
-     data/rodata, including from any source file
-     named rtc_wake_stub*.c
-  */
-  .rtc.data :
-  {
-    _rtc_data_start = ABSOLUTE(.);
-    *(.rtc.data)
-    *(.rtc.rodata)
-    *rtc_wake_stub*.o(.data .rodata .data.* .rodata.* .bss .bss.*)
-    _rtc_data_end = ABSOLUTE(.);
-  } > rtc_slow_seg
-
-  /* RTC bss, from any source file named rtc_wake_stub*.c */
-  .rtc.bss (NOLOAD) :
-  {
-    _rtc_bss_start = ABSOLUTE(.);
-    *rtc_wake_stub*.o(.bss .bss.*)
-    *rtc_wake_stub*.o(COMMON)
-    _rtc_bss_end = ABSOLUTE(.);
-  } > rtc_slow_seg
-
-  /* Send .iram0 code to iram */
-  .iram0.vectors : ALIGN(4)
-  {
-    /* Vectors go to IRAM */
-    _init_start = ABSOLUTE(.);
-    /* Vectors according to builds/RF-2015.2-win32/esp108_v1_2_s5_512int_2/config.html */
-    . = 0x0;
-    KEEP(*(.WindowVectors.text));
-    . = 0x180;
-    KEEP(*(.Level2InterruptVector.text));
-    . = 0x1c0;
-    KEEP(*(.Level3InterruptVector.text));
-    . = 0x200;
-    KEEP(*(.Level4InterruptVector.text));
-    . = 0x240;
-    KEEP(*(.Level5InterruptVector.text));
-    . = 0x280;
-    KEEP(*(.DebugExceptionVector.text));
-    . = 0x2c0;
-    KEEP(*(.NMIExceptionVector.text));
-    . = 0x300;
-    KEEP(*(.KernelExceptionVector.text));
-    . = 0x340;
-    KEEP(*(.UserExceptionVector.text));
-    . = 0x3C0;
-    KEEP(*(.DoubleExceptionVector.text));
-    . = 0x400;
-    *(.*Vector.literal)
-
-    *(.UserEnter.literal);
-    *(.UserEnter.text);
-    . = ALIGN (16);
-    *(.entry.text)
-    *(.init.literal)
-    *(.init)
-    _init_end = ABSOLUTE(.);
-
-    /* This goes here, not at top of linker script, so addr2line finds it last,
-       and uses it in preference to the first symbol in IRAM */
-    _iram_start = ABSOLUTE(0);
-  } GROUP_LINK_IN(IRAM_REGION)
-
-  SECTION_DATA_PROLOGUE(k_objects,, ALIGN(4))
+  /* Reserve space for MCUboot header in the binary */
+  .mcuboot_header :
   {
-    Z_LINK_ITERABLE_GC_ALLOWED(k_timer);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_mem_slab);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_mem_pool);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_heap);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_mutex);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_stack);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_msgq);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_mbox);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_pipe);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_sem);
-    . = ALIGN(4);
-    Z_LINK_ITERABLE_GC_ALLOWED(k_queue);
-  } GROUP_DATA_LINK_IN(RAMABLE_REGION, ROMABLE_REGION)
-
-  SECTION_DATA_PROLOGUE(net,, ALIGN(4))
+    QUAD(0x0)
+    QUAD(0x0)
+    QUAD(0x0)
+    QUAD(0x0)
+  } > mcuboot_hdr
+  .metadata :
   {
-    _esp_net_buf_pool_list = .;
-    KEEP(*(SORT_BY_NAME("._net_buf_pool.static.*")))
-
-#if defined(CONFIG_NETWORKING)
-    Z_LINK_ITERABLE_ALIGNED(net_if, 4);
-    Z_LINK_ITERABLE_ALIGNED(net_if_dev, 4);
-    Z_LINK_ITERABLE_ALIGNED(net_l2, 4);
-#endif
-
-  } GROUP_DATA_LINK_IN(RAMABLE_REGION, ROMABLE_REGION)
-
-  ITERABLE_SECTION_RAM(_static_thread_data, 4)
+    /* Magic byte for load header */
+    LONG(0xace637d3)
 
-#pragma push_macro("ITERABLE_SECTION_RAM")
-#pragma push_macro("ITERABLE_SECTION_RAM_GC_ALLOWED")
-#undef ITERABLE_SECTION_RAM_GC_ALLOWED
-#define ITERABLE_SECTION_RAM_GC_ALLOWED(x, y)
-#undef ITERABLE_SECTION_RAM
-#define ITERABLE_SECTION_RAM(x, y)
-#include <linker/common-ram.ld>
-/* Restore original value for symbols referenced by `common-ram.ld` */
-_net_buf_pool_list = _esp_net_buf_pool_list;
-#pragma pop_macro("ITERABLE_SECTION_RAM_GC_ALLOWED")
-#pragma pop_macro("ITERABLE_SECTION_RAM")
-
-  .dram0.data :
-  {
-    _data_start = ABSOLUTE(.);
-
-    _btdm_data_start = ABSOLUTE(.);
-    *libbtdm_app.a:(.data .data.*)
-    . = ALIGN (4);
-    _btdm_data_end = ABSOLUTE(.);
-
-    *(.data)
-    *(.data.*)
-    *(.gnu.linkonce.d.*)
-    *(.data1)
-    *(.sdata)
-    *(.sdata.*)
-    *(.gnu.linkonce.s.*)
-    *(.sdata2)
-    *(.sdata2.*)
-    *(.gnu.linkonce.s2.*)
-    /* rodata for panic handler(libarch__xtensa__core.a) and all
-     * dependent functions should be placed in DRAM to avoid issue
-     * when flash cache is disabled */
-    *libarch__xtensa__core.a:(.rodata .rodata.*)
-    *libkernel.a:fatal.*(.rodata .rodata.*)
-    *libkernel.a:init.*(.rodata .rodata.*)
-    *libzephyr.a:cbprintf_complete*(.rodata .rodata.*)
-    *libzephyr.a:log_core.*(.rodata .rodata.*)
-    *libzephyr.a:log_backend_uart.*(.rodata .rodata.*)
-    *libzephyr.a:log_output.*(.rodata .rodata.*)
-    *libdrivers__flash.a:flash_esp32.*(.rodata  .rodata.*)
-    *libdrivers__serial.a:uart_esp32.*(.rodata .rodata.*)
+    /* Application entry point address */
+    KEEP(*(.entry_addr))
 
-   . = ALIGN(4);
-    __esp_log_const_start = .;
-    KEEP(*(SORT(.log_const_*)));
-    __esp_log_const_end = .;
+    /* IRAM metadata:
+     * - Destination address (VMA) for IRAM region
+     * - Flash offset (LMA) for start of IRAM region
+     * - Size of IRAM region
+     */
 
-    . = ALIGN(4);
-    __esp_log_backends_start = .;
-    KEEP(*("._log_backend.*"));
-    __esp_log_backends_end = .;
+    LONG(ADDR(".iram0.vectors"))
+    LONG(LOADADDR(".iram0.vectors"))
+    LONG(LOADADDR(_TEXT_SECTION_NAME) + SIZEOF(_TEXT_SECTION_NAME) - LOADADDR(".iram0.vectors"))
 
-    KEEP(*(.jcr))
-    *(.dram1 .dram1.*)
-    _data_end = ABSOLUTE(.);
-    . = ALIGN(4);
-  } GROUP_LINK_IN(RAMABLE_REGION)
+    /* DRAM metadata:
+     * - Destination address (VMA) for DRAM region
+     * - Flash offset (LMA) for start of DRAM region
+     * - Size of DRAM region
+     */
 
-#if defined(CONFIG_ESP_SPIRAM)
-  .ext_ram.bss (NOLOAD):
-  {
-    _ext_ram_data_start = ABSOLUTE(.);
-    *(.ext_ram.bss*)
-    _ext_ram_data_end = ABSOLUTE(.) + CONFIG_ESP_SPIRAM_SIZE;
-  } > ext_ram_seg
-#endif
+    LONG(ADDR(".dram0.data"))
+    LONG(LOADADDR(".dram0.data"))
+    LONG(LOADADDR(".dummy.dram.data") + SIZEOF(".dummy.dram.data") - LOADADDR(".dram0.data"))
+  } > metadata
 
- SECTION_PROLOGUE(_RODATA_SECTION_NAME,,ALIGN(20))
+#include <linker/rel-sections.ld>
+  _image_drom_start = LOADADDR(_RODATA_SECTION_NAME);
+  _image_drom_size = LOADADDR(_RODATA_SECTION_NAME) + SIZEOF(_RODATA_SECTION_NAME) - _image_drom_start;
+  _image_drom_vaddr = ADDR(_RODATA_SECTION_NAME);
+
+  /* NOTE: .rodata section should be the first section in the linker script and no
+   * other section should appear before .rodata section. This is the requirement
+   * to align ROM section to 64K page offset.
+   * Adding .rodata as first section helps to reduce size of generated binary by
+   * few kBs.
+   */
+  SECTION_PROLOGUE(_RODATA_SECTION_NAME,,)
   {
     _rodata_start = ABSOLUTE(.);
 
@@ -324,8 +204,9 @@ _net_buf_pool_list = _esp_net_buf_pool_list;
     __esp_shell_root_cmds_end = .;
 
     . = ALIGN(4);
-    *(.rodata)
-    *(.rodata.*)
+    *(EXCLUDE_FILE (*libarch__xtensa__core.a:* *libkernel.a:fatal.* *libkernel.a:init.* *libzephyr.a:cbprintf_complete* *libzephyr.a:log_core.* *libzephyr.a:log_backend_uart.* *libzephyr.a:log_output.* *libzephyr.a:loader.* *libdrivers__flash.a:flash_esp32.* *libdrivers__serial.a:uart_esp32.*) .rodata)
+    *(EXCLUDE_FILE (*libarch__xtensa__core.a:* *libkernel.a:fatal.* *libkernel.a:init.* *libzephyr.a:cbprintf_complete* *libzephyr.a:log_core.* *libzephyr.a:log_backend_uart.* *libzephyr.a:log_output.* *libzephyr.a:loader.* *libdrivers__flash.a:flash_esp32.* *libdrivers__serial.a:uart_esp32.*) .rodata.*)
+
     *(.gnu.linkonce.r.*)
     *(.rodata1)
     __XT_EXCEPTION_TABLE__ = ABSOLUTE(.);
@@ -353,27 +234,116 @@ _net_buf_pool_list = _esp_net_buf_pool_list;
     *(.gnu.version_d)
     . = ALIGN(4);               /* this table MUST be 4-byte aligned */
     _rodata_end = ABSOLUTE(.);
-  } GROUP_LINK_IN(ROMABLE_REGION)
-
-#pragma push_macro("ITERABLE_SECTION_ROM")
-#pragma push_macro("ROMABLE_REGION")
-#undef ITERABLE_SECTION_ROM
-#define ITERABLE_SECTION_ROM(x,y)
-#undef ROMABLE_REGION
-/* This is to workaround limitation of `esptool` which needs single `FLASH` data segment
- * which is already defined above. In case, `common-rom.ld` creates additional segments
- * they will be placed in DRAM instead. */
-#define ROMABLE_REGION RAMABLE_REGION
-#include <linker/common-rom.ld>
-/* Restore original value for symbols referenced by `common-rom.ld` */
-__log_const_start = __esp_log_const_start;
-__log_const_end = __esp_log_const_end;
-__log_backends_start = __esp_log_backends_start;
-__log_backends_end = __esp_log_backends_end;
-__shell_root_cmds_start = __esp_shell_root_cmds_start;
-__shell_root_cmds_end = __esp_shell_root_cmds_end;
-#pragma pop_macro("ROMABLE_REGION")
-#pragma pop_macro("ITERABLE_SECTION_ROM")
+  } GROUP_DATA_LINK_IN(RODATA_REGION, ROMABLE_REGION)
+
+  _image_dram_start = LOADADDR(".dram0.data");
+  _image_dram_size = LOADADDR(".dummy.dram.data") + SIZEOF(".dummy.dram.data") - _image_dram_start;
+  _image_dram_vaddr = ADDR(".dram0.data");
+
+  .dram0.data :
+  {
+    _data_start = ABSOLUTE(.);
+
+    _btdm_data_start = ABSOLUTE(.);
+    *libbtdm_app.a:(.data .data.*)
+    . = ALIGN (4);
+    _btdm_data_end = ABSOLUTE(.);
+
+    *(.data)
+    *(.data.*)
+    *(.gnu.linkonce.d.*)
+    *(.data1)
+    *(.sdata)
+    *(.sdata.*)
+    *(.gnu.linkonce.s.*)
+    *(.sdata2)
+    *(.sdata2.*)
+    *(.gnu.linkonce.s2.*)
+    /* rodata for panic handler(libarch__xtensa__core.a) and all
+     * dependent functions should be placed in DRAM to avoid issue
+     * when flash cache is disabled */
+    *libarch__xtensa__core.a:(.rodata .rodata.*)
+    *libkernel.a:fatal.*(.rodata .rodata.*)
+    *libkernel.a:init.*(.rodata .rodata.*)
+    *libzephyr.a:cbprintf_complete*(.rodata .rodata.*)
+    *libzephyr.a:log_core.*(.rodata .rodata.*)
+    *libzephyr.a:log_backend_uart.*(.rodata .rodata.*)
+    *libzephyr.a:log_output.*(.rodata .rodata.*)
+    *libzephyr.a:loader.*(.rodata .rodata.*)
+    *libdrivers__flash.a:flash_esp32.*(.rodata  .rodata.*)
+    *libdrivers__serial.a:uart_esp32.*(.rodata .rodata.*)
+
+    KEEP(*(.jcr))
+    *(.dram1 .dram1.*)
+    . = ALIGN(4);
+    _dram_data_end = ABSOLUTE(.);
+  } GROUP_DATA_LINK_IN(RAMABLE_REGION, ROMABLE_REGION)
+
+  #pragma push_macro("GROUP_ROM_LINK_IN")
+  #pragma push_macro("ITERABLE_SECTION_ROM")
+  #undef GROUP_ROM_LINK_IN
+  #undef ITERABLE_SECTION_ROM
+  #define GROUP_ROM_LINK_IN GROUP_DATA_LINK_IN
+  #define ITERABLE_SECTION_ROM(x,y)
+  #include <linker/common-rom.ld>
+  #pragma pop_macro("GROUP_ROM_LINK_IN")
+  #pragma pop_macro("ITERABLE_SECTION_ROM")
+  #include <linker/common-ram.ld>
+
+  __shell_root_cmds_start = __esp_shell_root_cmds_start;
+  __shell_root_cmds_end = __esp_shell_root_cmds_end;
+
+  .dummy.dram.data :
+  {
+    . = ALIGN(4);
+    _data_end = ABSOLUTE(.);
+  } GROUP_DATA_LINK_IN(RAMABLE_REGION, ROMABLE_REGION)
+
+  _image_iram_start = LOADADDR(".iram0.vectors");
+  _image_iram_size = LOADADDR(_TEXT_SECTION_NAME) + SIZEOF(_TEXT_SECTION_NAME) - _image_iram_start;
+  _image_iram_vaddr = ADDR(".iram0.vectors");
+
+  /* Send .iram0 code to iram */
+  .iram0.vectors : ALIGN(4)
+  {
+    /* Vectors go to IRAM */
+    _init_start = ABSOLUTE(.);
+    /* Vectors according to builds/RF-2015.2-win32/esp108_v1_2_s5_512int_2/config.html */
+    . = 0x0;
+    KEEP(*(.WindowVectors.text));
+    . = 0x180;
+    KEEP(*(.Level2InterruptVector.text));
+    . = 0x1c0;
+    KEEP(*(.Level3InterruptVector.text));
+    . = 0x200;
+    KEEP(*(.Level4InterruptVector.text));
+    . = 0x240;
+    KEEP(*(.Level5InterruptVector.text));
+    . = 0x280;
+    KEEP(*(.DebugExceptionVector.text));
+    . = 0x2c0;
+    KEEP(*(.NMIExceptionVector.text));
+    . = 0x300;
+    KEEP(*(.KernelExceptionVector.text));
+    . = 0x340;
+    KEEP(*(.UserExceptionVector.text));
+    . = 0x3C0;
+    KEEP(*(.DoubleExceptionVector.text));
+    . = 0x400;
+    *(.*Vector.literal)
+
+    *(.UserEnter.literal);
+    *(.UserEnter.text);
+    . = ALIGN (16);
+    *(.entry.text)
+    *(.init.literal)
+    *(.init)
+    _init_end = ABSOLUTE(.);
+
+    /* This goes here, not at top of linker script, so addr2line finds it last,
+       and uses it in preference to the first symbol in IRAM */
+    _iram_start = ABSOLUTE(0);
+  } GROUP_DATA_LINK_IN(IRAM_REGION, ROMABLE_REGION)
 
   SECTION_PROLOGUE(_TEXT_SECTION_NAME, , ALIGN(4))
   {
@@ -404,6 +374,7 @@ __shell_root_cmds_end = __esp_shell_root_cmds_end;
     *libdrivers__console.a:uart_console.*(.literal.console_out .text.console_out)
     *libzephyr.a:log_output.*(.literal .text .literal.* .text.*)
     *libzephyr.a:log_backend_uart.*(.literal .text .literal.* .text.*)
+    *libzephyr.a:loader.*(.literal .text .literal.* .text.*)
     *liblib__libc__minimal.a:string.*(.literal .text .literal.* .text.*)
     *libphy.a:( .phyiram .phyiram.*)
     *libgcov.a:(.literal .text .literal.* .text.*)
@@ -421,33 +392,39 @@ __shell_root_cmds_end = __esp_shell_root_cmds_end;
     _iram_text_end = ABSOLUTE(.);
     . = ALIGN(4);
     _iram_end = ABSOLUTE(.);
-  } GROUP_LINK_IN(IRAM_REGION)
+  } GROUP_DATA_LINK_IN(IRAM_REGION, ROMABLE_REGION)
 
-  .flash.text :
+  /* RTC fast memory holds RTC wake stub code,
+     including from any source file named rtc_wake_stub*.c
+  */
+  .rtc.text :
   {
-    _stext = .;
-    _text_start = ABSOLUTE(.);
-
-#if !defined(CONFIG_ESP32_WIFI_IRAM_OPT)
-    *libnet80211.a:( .wifi0iram  .wifi0iram.* .wifislpiram .wifislpiram.*)
-    *libpp.a:( .wifi0iram  .wifi0iram.* .wifislpiram .wifislpiram.*)
-#endif
-
-#if !defined(CONFIG_ESP32_WIFI_RX_IRAM_OPT)
-    *libnet80211.a:( .wifirxiram  .wifirxiram.* .wifislprxiram .wifislprxiram.*)
-    *libpp.a:( .wifirxiram  .wifirxiram.* .wifislprxiram .wifislprxiram.*)
-#endif
+    . = ALIGN(4);
+    *(.rtc.literal .rtc.text)
+    *rtc_wake_stub*.o(.literal .text .literal.* .text.*)
+  } GROUP_DATA_LINK_IN(rtc_iram_seg, ROMABLE_REGION)
 
-    *(.literal .text .literal.* .text.*)
-    _text_end = ABSOLUTE(.);
-    _etext = .;
+  /* RTC slow memory holds RTC wake stub
+     data/rodata, including from any source file
+     named rtc_wake_stub*.c
+  */
+  .rtc.data :
+  {
+    _rtc_data_start = ABSOLUTE(.);
+    *(.rtc.data)
+    *(.rtc.rodata)
+    *rtc_wake_stub*.o(.data .rodata .data.* .rodata.* .bss .bss.*)
+    _rtc_data_end = ABSOLUTE(.);
+  } GROUP_DATA_LINK_IN(rtc_slow_seg, ROMABLE_REGION)
 
-    /* Similar to _iram_start, this symbol goes here so it is
-       resolved by addr2line in preference to the first symbol in
-       the flash.text segment.
-    */
-    _flash_cache_start = ABSOLUTE(0);
-  } GROUP_LINK_IN(FLASH_CODE_REGION)
+  /* RTC bss, from any source file named rtc_wake_stub*.c */
+  .rtc.bss (NOLOAD) :
+  {
+    _rtc_bss_start = ABSOLUTE(.);
+    *rtc_wake_stub*.o(.bss .bss.*)
+    *rtc_wake_stub*.o(COMMON)
+    _rtc_bss_end = ABSOLUTE(.);
+  } GROUP_LINK_IN(rtc_slow_seg)
 
   /* Shared RAM */
   SECTION_DATA_PROLOGUE(_BSS_SECTION_NAME,(NOLOAD),)
@@ -492,6 +469,46 @@ __shell_root_cmds_end = __esp_shell_root_cmds_end;
     . = ALIGN (8);
   } GROUP_LINK_IN(RAMABLE_REGION_1)
 
+#if defined(CONFIG_ESP_SPIRAM)
+  .ext_ram.bss (NOLOAD):
+  {
+    _ext_ram_data_start = ABSOLUTE(.);
+    *(.ext_ram.bss*)
+    _ext_ram_data_end = ABSOLUTE(.) + CONFIG_ESP_SPIRAM_SIZE;
+  } > ext_ram_seg
+#endif
+
+  _image_irom_start = LOADADDR(".flash.text");
+  _image_irom_size = LOADADDR(".flash.text") + SIZEOF(".flash.text") - _image_irom_start;
+  _image_irom_vaddr = ADDR(".flash.text");
+
+  .flash.text : ALIGN(IROM_SEG_ALIGN)
+  {
+    _stext = .;
+    _text_start = ABSOLUTE(.);
+
+#if !defined(CONFIG_ESP32_WIFI_IRAM_OPT)
+    *libnet80211.a:( .wifi0iram  .wifi0iram.* .wifislpiram .wifislpiram.*)
+    *libpp.a:( .wifi0iram  .wifi0iram.* .wifislpiram .wifislpiram.*)
+#endif
+
+#if !defined(CONFIG_ESP32_WIFI_RX_IRAM_OPT)
+    *libnet80211.a:( .wifirxiram  .wifirxiram.* .wifislprxiram .wifislprxiram.*)
+    *libpp.a:( .wifirxiram  .wifirxiram.* .wifislprxiram .wifislprxiram.*)
+#endif
+
+    *(.literal .text .literal.* .text.*)
+    . = ALIGN(4);
+    _text_end = ABSOLUTE(.);
+    _etext = .;
+
+    /* Similar to _iram_start, this symbol goes here so it is
+       resolved by addr2line in preference to the first symbol in
+       the flash.text segment.
+    */
+    _flash_cache_start = ABSOLUTE(0);
+  } GROUP_DATA_LINK_IN(FLASH_CODE_REGION, ROMABLE_REGION)
+
 #ifdef CONFIG_GEN_ISR_TABLES
 #include <linker/intlist.ld>
 #endif
-- 
2.33.1

