From 05f85cf686a1af3a685061eedceb01d2625a5b0b Mon Sep 17 00:00:00 2001
From: Shubham Kulkarni <shubham.kulkarni@espressif.com>
Date: Mon, 30 Aug 2021 17:20:17 +0530
Subject: [PATCH] soc: esp32: Update startup code to map IROM and DROM segments

This change updates startup code to setup MMU mappings

Signed-off-by: Shubham Kulkarni <shubham.kulkarni@espressif.com>
---
 soc/xtensa/esp32/CMakeLists.txt |  1 +
 soc/xtensa/esp32/loader.c       | 96 +++++++++++++++++++++++++++++++++
 soc/xtensa/esp32/soc.c          |  2 +-
 soc/xtensa/esp32/soc.h          |  2 +
 4 files changed, 100 insertions(+), 1 deletion(-)
 create mode 100644 soc/xtensa/esp32/loader.c

diff --git a/soc/xtensa/esp32/CMakeLists.txt b/soc/xtensa/esp32/CMakeLists.txt
index 49d6ea7689..9efc44acd5 100644
--- a/soc/xtensa/esp32/CMakeLists.txt
+++ b/soc/xtensa/esp32/CMakeLists.txt
@@ -3,4 +3,5 @@
 zephyr_sources(
   soc.c
   esp32-mp.c
+  loader.c
   )
diff --git a/soc/xtensa/esp32/loader.c b/soc/xtensa/esp32/loader.c
new file mode 100644
index 0000000000..ba92e9da63
--- /dev/null
+++ b/soc/xtensa/esp32/loader.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2021 Espressif Systems (Shanghai) Co., Ltd.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr.h>
+#include <soc.h>
+#include <storage/flash_map.h>
+#include <esp_log.h>
+
+#include <esp32/rom/cache.h>
+#include <soc/dport_reg.h>
+#include <bootloader_flash_priv.h>
+
+#ifdef CONFIG_BOOTLOADER_MCUBOOT
+#define HDR_ATTR __attribute__((section(".entry_addr"))) __attribute__((used))
+
+extern uint32_t _image_irom_start, _image_irom_size, _image_irom_vaddr;
+extern uint32_t _image_drom_start, _image_drom_size, _image_drom_vaddr;
+
+void __start(void);
+
+static HDR_ATTR void (*_entry_point)(void) = &__start;
+
+static int map_rom_segments(void)
+{
+	int rc = 0;
+	size_t _partition_offset = FLASH_AREA_OFFSET(image_0);
+	uint32_t _app_irom_start = _partition_offset +
+		(uint32_t)&_image_irom_start;
+	uint32_t _app_irom_size = (uint32_t)&_image_irom_size;
+	uint32_t _app_irom_vaddr = (uint32_t)&_image_irom_vaddr;
+
+	uint32_t _app_drom_start = _partition_offset +
+		(uint32_t)&_image_drom_start;
+	uint32_t _app_drom_size = (uint32_t)&_image_drom_size;
+	uint32_t _app_drom_vaddr = (uint32_t)&_image_drom_vaddr;
+
+	Cache_Read_Disable(0);
+	Cache_Flush(0);
+	/* Clear the MMU entries that are already set up,
+	 * so the new app only has the mappings it creates.
+	 */
+	for (int i = 0; i < DPORT_FLASH_MMU_TABLE_SIZE; i++) {
+		DPORT_PRO_FLASH_MMU_TABLE[i] =
+			DPORT_FLASH_MMU_TABLE_INVALID_VAL;
+	}
+
+	uint32_t drom_vaddr_addr_aligned = _app_drom_vaddr & MMU_FLASH_MASK;
+	uint32_t drom_page_count = bootloader_cache_pages_to_map(_app_drom_size,
+			_app_drom_vaddr);
+	rc = cache_flash_mmu_set(0, 0, drom_vaddr_addr_aligned, _app_drom_start
+			& MMU_FLASH_MASK, 64, drom_page_count);
+	rc |= cache_flash_mmu_set(1, 0, drom_vaddr_addr_aligned, _app_drom_start
+			& MMU_FLASH_MASK, 64, drom_page_count);
+
+	uint32_t irom_vaddr_addr_aligned = _app_irom_vaddr & MMU_FLASH_MASK;
+	uint32_t irom_page_count = bootloader_cache_pages_to_map(_app_irom_size,
+			_app_irom_vaddr);
+	rc |= cache_flash_mmu_set(0, 0, irom_vaddr_addr_aligned, _app_irom_start
+			& MMU_FLASH_MASK, 64, irom_page_count);
+	rc |= cache_flash_mmu_set(1, 0, irom_vaddr_addr_aligned, _app_irom_start
+			& MMU_FLASH_MASK, 64, irom_page_count);
+
+	DPORT_REG_CLR_BIT(DPORT_PRO_CACHE_CTRL1_REG,
+			(DPORT_PRO_CACHE_MASK_IRAM0) |
+			(DPORT_PRO_CACHE_MASK_IRAM1 & 0) |
+			(DPORT_PRO_CACHE_MASK_IROM0 & 0) |
+			DPORT_PRO_CACHE_MASK_DROM0 |
+			DPORT_PRO_CACHE_MASK_DRAM1);
+
+	DPORT_REG_CLR_BIT(DPORT_APP_CACHE_CTRL1_REG,
+			(DPORT_APP_CACHE_MASK_IRAM0) |
+			(DPORT_APP_CACHE_MASK_IRAM1 & 0) |
+			(DPORT_APP_CACHE_MASK_IROM0 & 0) |
+			DPORT_APP_CACHE_MASK_DROM0 |
+			DPORT_APP_CACHE_MASK_DRAM1);
+
+	esp_rom_Cache_Read_Enable(0);
+	return rc;
+}
+#endif
+
+void __start(void)
+{
+#ifdef CONFIG_BOOTLOADER_MCUBOOT
+	int err = map_rom_segments();
+
+	if (err != 0) {
+		ets_printf("Failed to setup XIP, aborting\n");
+		abort();
+	}
+#endif
+	__esp_platform_start();
+}
diff --git a/soc/xtensa/esp32/soc.c b/soc/xtensa/esp32/soc.c
index 8dbe30dad8..90803d0d46 100644
--- a/soc/xtensa/esp32/soc.c
+++ b/soc/xtensa/esp32/soc.c
@@ -34,7 +34,7 @@ extern void z_cstart(void);
  * Zephyr is being booted by the Espressif bootloader.  With it, the C stack
  * is already set up.
  */
-void __attribute__((section(".iram1"))) __start(void)
+void __attribute__((section(".iram1"))) __esp_platform_start(void)
 {
 	volatile uint32_t *wdt_rtc_protect = (uint32_t *)RTC_CNTL_WDTWPROTECT_REG;
 	volatile uint32_t *wdt_rtc_reg = (uint32_t *)RTC_CNTL_WDTCONFIG0_REG;
diff --git a/soc/xtensa/esp32/soc.h b/soc/xtensa/esp32/soc.h
index 15cf0fed08..18b86aabd3 100644
--- a/soc/xtensa/esp32/soc.h
+++ b/soc/xtensa/esp32/soc.h
@@ -19,6 +19,8 @@
 #include <xtensa/core-macros.h>
 #include <esp32/clk.h>
 
+void __esp_platform_start(void);
+
 static inline void esp32_set_mask32(uint32_t v, uint32_t mem_addr)
 {
 	sys_write32(sys_read32(mem_addr) | v, mem_addr);
-- 
2.33.1

